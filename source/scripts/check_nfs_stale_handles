#!/usr/bin/php
<?php
/* Copyright 2020-2021, Dan Landon
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version 2,
 * as published by the Free Software Foundation.
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 */

$plugin		= "unassigned.devices";
$docroot	= $docroot ?? $_SERVER['DOCUMENT_ROOT'] ?: '/usr/local/emhttp';
$paths = [	"smb_usb_shares"	=> "/etc/samba/unassigned-shares",
			"usb_mountpoint"	=> "/mnt/disks",
			"remote_mountpoint"	=> "/mnt/remotes",
			"config_file"		=> "/tmp/{$plugin}/config/samba_mount.cfg",
			"ping_status"		=> "/var/state/{$plugin}/ping_status.json"
		];

$pid_file	= "/var/run/stale-handles.pid";

/* Unassigned Devices logging. */
function unassigned_log($m, $type = "NOTICE") {
	global $plugin;

	if ($type == "DEBUG" && ! $GLOBALS["VERBOSE"]) return NULL;
	$m		= print_r($m,true);
	$m		= str_replace("\n", " ", $m);
	$m		= str_replace('"', "'", $m);
	exec("/usr/bin/logger"." ".escapeshellarg($m)." -t ".escapeshellarg($plugin));
}

/* Run a command and time out if it doesn't complete in the $timeout number of seconds. */
function timed_exec($timeout = 10, $cmd) {
	$time		= -microtime(true); 
	$out		= shell_exec("/usr/bin/timeout ".escapeshellarg($timeout)." ".$cmd);
	$time		+= microtime(true);
	if ($time >= $timeout) {
		unassigned_log("Error: shell_exec(".$cmd.") took longer than ".sprintf('%d', $timeout)."s!");
		$out	= "command timed out";
	} else {
		unassigned_log("Timed Exec: shell_exec(".$cmd.") took ".sprintf('%f', $time)."s!", "DEBUG");
	}
	return $out;
}

/* Is the server currently on line. */
function is_server_online($server) {
	global $paths;

	/* Check the last ping status. */
	$tc				= $paths['ping_status'];
	$ping_status	= is_file($tc) ? json_decode(file_get_contents($tc),TRUE) : array();
	$is_alive		= ($ping_status[$server]['online'] == 'yes') ? TRUE : FALSE;

	return $is_alive;
}

unlink($pid_file);
if (! file_exists($pid_file)) {
	/* Create pid to show check stale file handle is running. */
	$pid = getmypid();
	file_put_contents($pid_file, $pid);

	/* Setup syslog filtering to get rid of all the stale file handle messages. */
	$rsyslog_conf	= "/etc/rsyslog.conf";
	$filter_file	="/etc/rsyslog.d/03-blocklist-extra.conf";

	if (! file_exists($filter_file)) {
		$filter[] = ":msg,contains,\"fileid changed\" stop\n";
		$filter[] = ":msg,contains,\"expected fileid\" stop\n";
		file_put_contents($filter_file, $filter);

		/* Setup log rules */
		@chmod($filter_file, 0644);

		sleep(1);

		/* Adjust rsyslog.conf so filtering will work. */
		$str = file_get_contents($rsyslog_conf);
		$str = str_replace("RuleSet local", "RuleSet RSYSLOG_DefaultRuleset", $str);
		$str = str_replace("DefaultRuleset local", "DefaultRuleset RSYSLOG_DefaultRuleset", $str);
		file_put_contents($rsyslog_conf, $str);

		/* Restart rsyslog */
		shell_exec("/etc/rc.d/rc.rsyslogd restart");
	}

	/* See if we have a stale file handle and if so unmount and remount the remote share. */
	do {
		$samba_mounts	= @parse_ini_file($paths['config_file'], true);
		if (is_array($samba_mounts)) {
			foreach ($samba_mounts as $device => $mount) {
				$server		= $mount['ip'];
					/* Set the mount protocol. */
				if ($mount['protocol'] == "NFS") {
					$mount['fstype'] = "nfs";
					$path = basename($mount['path']);
				} else {
					$mount['fstype'] = "cifs";
					$path = $mount['path'];
				}

				if (! $mount['mountpoint']) {
					$mount['mountpoint'] = "{$paths['usb_mountpoint']}/{$mount['ip']}_{$path}";
					if (! $mount['mounted'] || ! is_mounted($mount['mountpoint'], TRUE) || is_link($mount['mountpoint'])) {
						$mount['mountpoint'] = "{$paths['remote_mountpoint']}/{$mount['ip']}_{$path}";
					}
				} else {
					$path = basename($mount['mountpoint']);
					$mount['mountpoint'] = "{$paths['usb_mountpoint']}/{$path}";
					if (! $mount['mounted'] || ! is_mounted($mount['mountpoint'], TRUE) || is_link($mount['mountpoint'])) {
						$mount['mountpoint'] = "{$paths['remote_mountpoint']}/{$path}";
					}
				}
				$mountpoint = $mount['mountpoint'];
				if (($mount['protocol'] == "NFS") && (is_server_online($server))) {
					$o = shell_exec("/bin/stat ".escapeshellarg($mountpoint)." 2>&1");
					if ((strpos($o, "Stale file handle") !== FALSE)) {
						unassigned_log("Warning: Stale file handle found on '".$mountpoint." - remounting.'");
						/* We have a stale file handle - unmount and remount the remote share. */
						timed_exec(1, "/sbin/umount -l ".escapeshellarg($device)." 2>&1");
						sleep(0.1);
						$params	= "rw,noacl,hard,timeo=600,retrans=10";
						timed_exec(10, "/sbin/mount -t nfs -o ".$params." ".escapeshellarg($device)." ".escapeshellarg($mountpoint)." 2>&1"."\n");

					}
				}
			}
		}

		/* Sleep for a while before checking again. */
		sleep(1);
	} while (TRUE);

	# Remove pid file to show check stale fie handle is not running.
	@unlink($pid_file);
} else {
	echo("Already running!\n");
}
?>
